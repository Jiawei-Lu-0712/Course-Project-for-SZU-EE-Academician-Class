# 小麻雀内核手册

## 1 概览
小麻雀内核是基于标准RISC-V指令集架构开发的32位通用MCU级处理器内核；采用2级流水线设计，大部分指令都为单周期；哈佛结构，采用ICB总线接口，最大支持4GB线性地址空间；支持参数化配置内核的各项指标。
### 1.1 关键特性
|项目|描述|
|-|-|
|指令集|RV32 I/E [M] Zicsr|
|流水线|2级|
|总线接口|ICB|
|总线阻塞|支持|
|程序存储器|核内，大小可配置|
|中断系统|向量中断|
|特权等级|仅M机器模式|
|C语言编程|支持|
|FPGA综合|支持|

### 1.2 指令集
小麻雀内核支持RV32 I/E \[M\] Zicsr指令集组合，可根据需求灵活配置。其中，`I`和`E`代表通用寄存器个数，必须二选一；`M`扩展是可选项。  
- RV32：32位RV架构，通用寄存器位宽为32位
  - I：支持基本整数指令，具有32个整数通用寄存器
  - E：支持基本整数指令，具有16个整数通用寄存器
- M：支持整数乘法指令和整数除法指令
- Zicsr：支持CSR空间和CSR指令

小麻雀内核对每条指令的处理方式符合RISC-V指令集架构的规范。在硬件实现层面上，大部分为单周期指令，`ld`总线读指令和除法指令是多周期指令。  
|指令|功能伪码|周期数|
|---|---|---|
||基本运算||
|add|rd=rs1+rs2 |1|
|sub|rd=rs1-rs2 |1|
|xor|rd=rs1^rs2 |1|
|or |rd=rs1\|rs2 |1|
|and|rd=rs1&rs2 |1|
|sll|rd=rs1<<rs2|1|
|srl|rd=rs1>>rs2|1|
|sra|rd=rs1>>rs2 高位扩展|1|
|slt|rd=(rs1<rs2)?1:0|1|
|sltu|(rd=rs1<rs2)?1:0 0扩展|1|
||带立即数运算||
|addi|rd=rs1+imm|1|
|xori|rd=rs1^imm |1|
|ori |rd=rs1\|imm |1|
|andi|rd=rs1&imm |1|
|slli|rd=rs1<<imm[0:4]|1|
|srli|rd=rs1>>imm[0:4]|1|
|srai|rd=rs1>>imm[0:4] 高位扩展|1|
|slti|rd=(rs1<imm)?1:0|1|
|sltiu|rd=(rs1<imm)?1:0 0扩展|1|
||读总线||
|lb|rd=M[rs1+imm][0: 7]|2|
|lh|rd=M[rs1+imm][0:15]|2|
|lw|rd=M[rs1+imm][0:31]|2|
|lbu|rd=M[rs1+imm][0:7] 0扩展|2|
|lhu|rd=M[rs1+imm][0:15] 0扩展|2|
||写总线||
|sb|M[rs1+imm][0: 7]=rs2[0: 7]|1/2(iram)|
|sh|M[rs1+imm][0:15]=rs2[0:15]|1/2(iram)|
|sw|M[rs1+imm][0:31]=rs2[0:31]|1/2(iram)|
||条件分支||
|beq|if(rs1==rs2) PC+=imm|1|
|bne|if(rs1!=rs2) PC+=imm|1|
|blt|if(rs1<rs2) PC+=imm|1|
|bge|if(rs1>=rs2) PC+=imm|1|
|bltu|if(rs1<rs2) PC+=imm 0扩展|1|
|bgeu|if(rs1>=rs2) PC+=imm 0扩展|1|
||跳转指令||
|jal|rd=PC+4; PC+=imm|1|
|jalr|rd=PC+4; PC=rs1+imm|1|
||装载立即数||
|lui|rd=imm<<12|1|
|auipc|rd=PC+(imm<<12)|1|
||中断相关||
|mret|中断返回|1|
|wfi|休眠等待中断唤醒|1|
||CSR相关||
|csrrw|CSR[imm]=rs1|1|
|csrrs|CSR[imm]=rs1\|CSR[imm]|1|
|csrrc|CSR[imm]=~rs1&CSR[imm]|1|
|csrrwi|CSR[imm]=zimm|1|
|csrrsi|CSR[imm]=zimm\|CSR[imm]|1|
|csrrci|CSR[imm]=~zimm&CSR[imm]|1|
||M扩展||
|mul|rd=rs1*rs2[0:31]|1|
|mulhu|无符号rd=rs1*rs2[32:63]|1|
|mulh|有符号rd=rs1*rs2[32:63]|1|
|mulsu|rd=有符号rs1*无符号rs2[32:63]|1|
|div|有符号rd=rs1/rs2|2-33|
|divu|无符号rd=rs1/rs2|2-33|
|rem|有符号rd=rs1%rs2|2-33|
|remu|无符号rd=rs1%rs2|2-33|


### 1.3 寄存器组GPR
RV32寄存器组的数据宽度都为32位，RV32I拥有x0-x31共32个寄存器组，RV32E拥有x0-x15共16个寄存器组。  
x0寄存器固定读为0、写忽略；x1-x31可读可写。每个寄存器虽然地位相同，但是在软件层面有一套约定俗成的功能定义。  

|寄存器|ABI名称|功能|储存者|
|-|-|-|-|
|x0|zero|硬编码0|-|
|x1|ra|返回地址|Caller|
|x2|sp|栈指针|Callee|
|x3|gp|全局指针|-|
|x4|tp|线程指针|-|
|x5-7|t0-2|临时寄存器|Caller|
|x8|s0/fp|保存寄存器/帧指针|Callee|
|x9|s1|保存寄存器|Callee|
|x10-11|a0-1|函数参数/返回值|Caller|
|x12-17|a2-7|函数参数|Caller|
|x18-27|s2-11|保存寄存器|Callee|
|x28-31|t3-6|临时寄存器|Caller|

Caller是被调过程不保存该寄存器值，Callee是被调过程保存该寄存器。   

### 1.4 特权模式
RISC-V包含了多种特权模式，小麻雀内核仅支持机器模式。机器模式具有最高的权限，该模式下程序可以访问所有的控制和状态寄存器(Control and Status Register,CSR)。    

## 2 功能框架
### 2.1 结构框图
小麻雀内核的结构如图所示：  
![内核原理图](/doc/图库/数据手册/内核原理图.svg)  

以IFU为界限，流水线切成两级：  
- 生成取指地址
- 译码、执行、写回

对于连续单周期指令，处理器在一个周期内会发生这些事：
- 一条指令从IFU取出，经过译码，把GPR中取出操作数给相应的执行单元，等执行完成后，产生写回的数据和下一条指令的地址(PC)。  
- 下一个时钟沿到来后，写回的数据写入GPR，下一条指令的地址给IFU取出下一条指令。  

### 2.2 内核端口
|名称|方向|位宽|功能|
|---|---|---|---|
|clk        |input |1|时钟输入，处理器核的唯一时钟|
|rst_n      |input |1|异步复位同步释放|
|halt_req_i |input |1|暂停处理器，高有效|
|hx_valid   |output|1|处理器活动指示，高有效|
|soft_rst   |output|1|软件复位请求，高有效|
|PLIC：| | | |
|core_ex_trap_valid_i|input|1|外部中断请求，高有效|
|core_ex_trap_id_i   |input|5|外部中断源ID|
|core_ex_trap_ready_o   |output|1|外部中断响应，高有效|
|core_ex_trap_cplet_o   |output|1|外部中断服务完成，高有效|
|core_ex_trap_cplet_id_o|output|5|外部中断服务完成的中断源ID|
|ICB Master：| | | |
|core_icb_cmd_valid|output|1|cmd有效|
|core_icb_cmd_ready|input |1|cmd准备好|
|core_icb_cmd_addr |output|32|cmd地址|
|core_icb_cmd_read |output|1|cmd读使能|
|core_icb_cmd_wdata|output|32|cmd写数据|
|core_icb_cmd_wmask|output|4|cmd写选通|
|core_icb_rsp_valid|input |1|rsp有效|
|core_icb_rsp_ready|output|1|rsp准备好|
|core_icb_rsp_err  |input |1|rsp错误|
|core_icb_rsp_rdata|input |32|rsp读数据|
|IFU：| | | |
|if_req_o|output|1|取指请求，高有效|
|if_addr_o|output|32|取指地址|
|if_ack_i|input|1|取指响应，高有效|
|if_data_i|input|32|取指数据|

### 2.3 IFU取指时序
取指端口有4个信号，可分为两组：  
- `if_req_o` `if_addr_o`发出取指请求和取指地址  
`if_req_o`是`if_addr_o`的有效标志。当`if_req_o`为1时，请求指令存储器从`if_addr_o`取出下一条指令。  
- `if_ack_i` `if_data_i`接收取指应答和指令数据  
`if_ack_i`是`if_data_i`的有效标志。当`if_ack_i`为1时，表示上一个`if_req_o`取指请求对应的指令成功取出，`if_data_i`是取出的指令。  

简而言之，`if_req_o`发起取指，下一拍若`if_ack_i`拉高，表示指令成功取出。  
需要注意，`if_req_o`拉高后，对应的`if_ack_i`不会出现在当前拍，而是出现在之后的周期，类似于流水线。  

下面使用波形图来表示取指端口的时序特征。  
颜色相同的`PCx+1`和`instx`，表示取出的指令`instx`和下一条指令地址`PCx+1`。  
颜色不同的`PCx`和`instx`，表示从`PCx`这个地址取出了指令`instx`。  
**单周期指令连续取指：**  
上一拍`if_req_o`拉高，下一拍`if_ack_i`也拉高，依次对应连续取指。  
![内核原理图](/doc/图库/数据手册/单周期指令连续取指.svg)  

**单周期指令取指被阻塞：**  
从`PC0`取出`inst0`后，立即在当前拍生成`PC1`并发出`if_req_o`请求，但是下一拍`if_ack_i`没有响应，等了3拍`if_ack_i`才拉高，取出`inst1`。  
![内核原理图](/doc/图库/数据手册/单周期指令取指被阻塞.svg)  

**多周期指令连续取指：**  
从`PC0`取出`inst0`后，`inst0`是一条多周期指令，没有立即发出`if_req_o`请求，等了2拍才生成`PC1`并发出`if_req_o`请求，然后取出`inst1`。  
![内核原理图](/doc/图库/数据手册/多周期指令连续取指.svg)  

**多周期指令取指被阻塞：**  
从`PC0`取出`inst0`后，`inst0`是一条多周期指令，没有立即发出`if_req_o`请求，等了2拍才生成`PC1`并发出`if_req_o`请求；但是下一拍`if_ack_i`没有响应，又等了3拍`if_ack_i`才拉高，取出`inst1`。  
![内核原理图](/doc/图库/数据手册/多周期指令取指被阻塞.svg)  

### ICB端口时序
参考蜂鸟E203，功能一致。  

## 3 CSR组织形式
小麻雀处理器实现了以下CSR寄存器，其中包含了RV ISA定义的标准CSR寄存器，也包含了自定义实现的CSR寄存器。  
程序可访问所有的CSR寄存器，写入只读寄存器不会触发任何异常。  
**RV ISA 标准CSR：**  
小麻雀处理器实现了部分M\<csr\>寄存器及其部分字段。  
|名称|地址|复位值|说明|
|----|----|-----|---|
|mstatus  |12'h300|32'h0|\[3\]\[7\]RW，其他字段RAZWI|
|misa     |12'h301|32'h40001100|只读|
|mvendorid|12'hF11|32'h114514|只读|
|marchid  |12'hF12|32'd1|只读|
|mimpid   |12'hF13|config.v配置决定|只读|
|mhartid  |12'hF14|32'd0|只读|
|minstret |12'hB02|32'h0|指令计数器\[31:0\]RW|
|minstreth|12'hB82|32'h0|指令计数器\[63:32\]RW|
|mip      |12'h344|32'h0|\[3\]\[7\]\[11\]有效，其他字段RAZWI|
|mie      |12'h304|32'h0|\[3\]\[7\]\[11\]RW，其他字段RAZWI|
|mtvec    |12'h305|32'h1|\[31:2\]RW \[1:0\]恒为2'b01|
|mscratch |12'h340|32'h0|\[31:0\]RW|
|mepc     |12'h341|32'h0|\[31:0\]RW|
|mcause   |12'h342|32'h0|\[31:0\]RW|
|mtval    |12'h343|32'h0|\[31:0\]RW|

RAZWI表示：读总为0，写忽略  

**自定义实现CSR：**  
小麻雀处理器通过自定义CSR实现了各种控制功能。  
|名称|地址|复位值|说明|
|----|----|-----|---|
|mprints  |12'h346|NULL|只写，仿真专用，写入mprints的字符会打印在终端上|
|mends    |12'h347|32'h0|只写，仿真专用，写1结束仿真|
|mcctr    |12'hB88|32'h0|\[4:0\]RW, \[31:5\]RAZWI|
|msip     |12'h345|32'h0|只写，写1触发软件中断|
|mtime    |12'hB03|32'h0|mtime\[31:0\] RW|
|mtimeh   |12'hB83|32'h0|mtime\[63:32\] RW|
|mtimecmp |12'hB04|32'hFFFFFFFF|mtimecmp\[31:0\] RW|
|mtimecmph|12'hB84|32'hFFFFFFFF|mtimecmp\[63:32\] RW|

|字段|功能|
|---|---|
|mcctr\[0\]|保留|
|mcctr\[1\]|1:minstret计数使能; 0:暂停计数|
|mcctr\[2\]|mtime计数使能; 0:暂停计数|
|mcctr\[3\]|写1软件复位|
|mcctr\[4\]|保留|


## 4 中断和异常
在小麻雀处理器中，发生**广义中断**后处理器进入陷阱(trap)，处理硬件错误、指令错误、中断请求等事务。这就像走路踩陷阱一样难以预测，并且立即脱离正常运行状态。  
**广义中断**包含了中断和异常，因为他们在处理器上产生的行为是一样，会暂停当前程序，保存现场，然后进入中断服务程序，处理完成后返回正常的程序流。中断既包含了定时器、串口等外设产生的中断，也包含了指令错误等内部发生的异常。  
因此，在小麻雀处理器的微架构实现中，使用`Trap编码`作为每一种**广义中断**的唯一标识。  
Trap编码对应唯一的中断来源，mcause[31]用于区分中断和异常，mcause[30:0]用于区分进入中断的原因。小麻雀处理器实现的中断和异常类型如下所示。  
|Trap编码|mcause\[31\]|mcause\[30:0\]|类型|
|---|---|---|---|
|0|-|-|保留|
|1|0|1|处理器核异常|
|2|1|2|核内软件中断|
|3|1|3|核内定时器中断|
|4-19|1|4-19|PLIC0-PLIC15中断|
|20-63|-|-|保留|

### 异常类型
小麻雀处理器仅支持一种异常，即`mcause==0x01`，表示内核发生功能错误。异常不可屏蔽，可嵌套触发。    
异常是同步的。  
一般情况下不会发生。  

### 中断类型
小麻雀处理器包含三种中断：软件中断、核内定时器中断、外部中断。  
中断在CSR机制上可以嵌套，但是trap控制器不支持嵌套，因此需按照不支持中断嵌套的方式编写程序。  
其中，核内软件中断、核内定时器中断是处理器核内部产生的，仅受CSR控制。  
`mtime`和`mtimecmp`位于CSR空间，当`mtime`大于等于`mtimecmp`时，若`mie.MTIE`没有屏蔽，则触发核内定时器中断。  
`msip`位于CSR空间，写1后，若`mie.MSIE`没有屏蔽，则触发核内软件中断。  
外部中断由PLIC(平台级中断控制器)接管。  
`PLIC`是挂载于ICB总线的外设，管理处理器平台的所有外部中断源。当PLIC向内核发起中断请求时，若`mie.MEIE`没有屏蔽，则根据PLIC传递的中断类型触发相应中断号的外部中断。  
小麻雀SoC的PLIC支持15个中断源，1个中断目标hart，PLIC1-PLIC15表示15个中断源，PLIC0保留。  

![中断类型](/doc/图库/数据手册/中断机制.svg)

### 中断处理过程
#### 中断控制器
小麻雀处理器支持3种中断，这些中断信号拉起后并不会被立即响应，而是需要先经过CSR寄存器构成的中断使能判断。  
其中，`mie.MSIE` `mie.MTIE` `mie.MEIE`分别控制软件中断、定时器中断、外部中断的使能，然后使用`mstatus.MIE`作为全局的中断使能信号。简而言之，若需要处理器响应某种类型的中断，必须将`mie.MxIE`和`mstatus.MIE`同时置为1，即分管某种中断的使能位和全局的中断使能位都需要打开。  
同时，通过`mip`寄存器可以看到有哪些中断等待被响应，且`mip`的状态不会受到`mie`中断使能控制的影响。  

#### 中断响应  
中断被响应后，处理器被`trap.v`的状态机接管，依次完成以下工作。  
1. 关闭全局中断  
为了防止中断处理过程被干扰，中断被响应后会关闭全局中断。  
同时，为了后期可以扩展中断嵌套功能，会保存当前的全局中断使能状态。  
```
mstatus.MPIE <= mstatus.MIE
mstatus.MIE  <= 0
```

2. 保存中断返回地址  
中断处理完成后，需要回到主程序中尚未执行那条指令，因此需要记录中断响应时的PC值。  
```
mepc <= PC
```

3. 记录中断原因  
中断有很多种，PLIC进一步扩展了外部中断，因此需要记录发生中断的原因，让中断服务程序知道怎么去处理。  
```
mcause <= 中断哪里来的？
```

4. 记录异常值  
如果是中断，mtval写0。  
如果是异常，mtval会记录具体的异常原因。  

5. 跳转到中断服务程序  
上文提到，`Trap编码`是每种**广义中断**的唯一标识，而小麻雀处理器采用的是向量中断机制。  
因此，使用`mtvec[31:2]`作为基地址，使用`Trap编码`乘以4作为偏移量，PC跳转到中断向量表。  
```
PC <= mtvec[31:2] + 4*Trap编码
```
中断向量表的每个表项只能存放一条指令，光凭这一条指令很明显不能完成中断处理工作。所以，中断向量表的每个表项放了一条无条件跳转指令jal，通过这条跳转指令再次跳转到真正的中断服务程序入口。 
若没有对应的中断服务程序，则中断向量表会放一条死循环程序。  
中断向量表见`/bsp/bsp_app/lib/startup/startup.S -> trap_vector_tab:`。  

#### 中断服务程序
中断服务程序会根据中断类型，完成相应的工作。但是，为了防止中断服务程序破坏原有程序的上下文环境，比如说x0-x31寄存器，需要先保存现场。  
GCC编译器很方便，使用`__attribute__((interrupt("machine")))`命令修饰中断服务程序的函数，就能在函数的入口和出口，自动生成保存和恢复现场的指令。见`/bsp/bsp_app/app/trap_handler.c`。    


#### 中断返回
完成中断处理，恢复现场后，通过`mret`指令返回之前的程序流，并且恢复中断前`mstatus.MIE`的值。  
```
PC <= mepc
mstatus.MIE  <= mstatus.MPIE
mstatus.MPIE <=0
```

### 异常处理过程
异常处理过程和中断是基本一样的，只有2点差别：  

1. 异常不可屏蔽
无论当前`mstatus` `mie`是什么状态，异常永远不能被屏蔽，且响应优先级更高。  

2. 在mtval中记录发生异常的关键信息
应该要在mtval中记录，但是目前还没有这种功能。  

### 外部中断接口
在RV架构层面，只定义了一个外部中断接口，但是处理器有各种各样的中断源，如定时器、串口、看门狗等，需要有一个外设来统一管理这些中断源。而RV架构定义了PLIC(平台级中断控制器)的工作流程，用于指导设计RV处理器的中断管理功能。
小麻雀处理器实现了一个用于管理外部中断源的PLIC，此PLIC支持最多15个中断源和1个中断目标(hart)。小麻雀内核有一组与PLIC通信的外部中断接口，用于接收外部中断。

|名称|方向|位宽|功能|
|---|---|---|---|
|ex_trap_valid_i  |input |1|外部中断请求有效|
|ex_trap_id_i     |input |5|外部中断源ID|
|ex_trap_ready_o  |output|1|外部中断响应|
|ex_trap_cplet_o  |output|1|外部中断完成|
|ex_trap_cplet_id_o |output|5|外部中断完成ID|

以下内容请参考[PLIC手册-中文版](/doc/参考资料/中文版riscv-plic-1.0.0.pdf)  
在处理器核视角，需要关注三个过程：`中断请求` `中断处理` `中断完成`  

**中断请求**  
当PLIC内核接受到来自某个中断源的中断信号后，会向中断目标(即内核)的外部中断接口发出中断请求，表示PLIC有一个ID为xx的外部中断需要处理器核来处理。  
PLIC发送中断请求有两个过程：  
- 发起请求
PLIC在`ex_trap_id_i外部中断源ID`通道上准备好中断源ID后，拉起信号`ex_trap_valid_i外部中断请求有效`向处理器核发起请求。   

- 等待响应
由于处理器核并不是在任意时刻都能接收外部中断，所以请求信号需要保持住。直到处理器核拉起信号`ex_trap_ready_o外部中断响应`，通知PLIC当前中断请求已接收，PLIC才能撤销请求信号。   

**中断处理**  
外部中断请求接收后，会拉起mip.MEIP表示有一个外部中断处于等待状态。响应此中断后，通过中断源ID生成Trap编码，进而得到mcause值和向量中断偏移量，最后进入中断服务程序。  

**中断完成**  
中断服务程序执行完毕后，通过`mret`指令回到正常的程序流。执行`mret`后处理器核拉起`ex_trap_cplet_o外部中断完成`信号，同时给出`ex_trap_cplet_id_o外部中断完成ID`表示此`mret`对应的中断源ID。  
